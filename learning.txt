██████╗ ███████╗     █████╗ ███╗   ██╗██████╗      █████╗ ██╗      ██████╗  ██████╗                   ██████╗ ██╗   ██╗████████╗██╗  ██╗ ██████╗ ███╗   ██╗
██╔══██╗██╔════╝    ██╔══██╗████╗  ██║██╔══██╗    ██╔══██╗██║     ██╔════╝ ██╔═══██╗                  ██╔══██╗╚██╗ ██╔╝╚══██╔══╝██║  ██║██╔═══██╗████╗  ██║
██║  ██║███████╗    ███████║██╔██╗ ██║██║  ██║    ███████║██║     ██║  ███╗██║   ██║    █████╗        ██████╔╝ ╚████╔╝    ██║   ███████║██║   ██║██╔██╗ ██║
██║  ██║╚════██║    ██╔══██║██║╚██╗██║██║  ██║    ██╔══██║██║     ██║   ██║██║   ██║    ╚════╝        ██╔═══╝   ╚██╔╝     ██║   ██╔══██║██║   ██║██║╚██╗██║
██████╔╝███████║    ██║  ██║██║ ╚████║██████╔╝    ██║  ██║███████╗╚██████╔╝╚██████╔╝                  ██║        ██║      ██║   ██║  ██║╚██████╔╝██║ ╚████║
╚═════╝ ╚══════╝    ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝     ╚═╝  ╚═╝╚══════╝ ╚═════╝  ╚═════╝                   ╚═╝        ╚═╝      ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝


Commit to git daily!! :  goal 21st Nov 2022

+-----------------------------------------------+
| Introduction -  Learning Everything in Python |
+-----------------------------------------------+

Goal:  you should be able to write code of any ds or algo without reference 
This way you commit to complete this course. Once we complete this course we could proceed 
with the data structure and algorithm 40 hours course.. 

+-----------------------------------+
| Starting with Coding and Learning |
+-----------------------------------+

Coding Editor :  So I have VS Code. Stay with this... 


+-----------------------------------+
| The Asymptotic Big - O - Notation |
+-----------------------------------+

Big-O :  Big O is way of comparing 2 code. So if 2 code 
accomplish the same thing but how do you compare? Big O comes here. 

Big-O Worst case : 

The Worst Case comes to a picture when your algorithm performs to its worst. 
Meaning a boundary condition or a scenario where the data for the code, or the number of operation increases 
or memory space increases. Now there are notation where you categorize the algorithms

Omega - The best case
Theta - The Average Case
Omicron - Worst Case 

+-------------------------------------------------------------+
| o(n) operations -  Number of times increases if N increases |
+-------------------------------------------------------------+

The O(n) on plotting on a graph brings out line with a slop of 45 degree angle 
Meaning, if your count increases the number of operation increases. So as 
higher count comes into picture, your algorithm might suffer through time complexity 
and takes up higher processing power. 


O(n) -  Operations increases with Number 
----------------------------------------

When you consider or write asymptotic notation you don't have to worry on how many times 
the code is repeated but focus on the operations which the code run 

O(n)^2 - Operations Geometrically increases with Number 
--------------------------------------------------------
 
When the operations have nested elements within, then we go to o(n)^2 which is what 
makes the algorithms to have a steeper curve in the time complexity of the code. 

under circumstances where there is an o(n) and o(n)^2 we always go for the dominant operational notation
Ensure to take this into account 

O(1) - Operations does not increases with Number
------------------------------------------------

In this case you might be wondering what would constitute a big-o Omega equation. This notation would be O(1)
o(1) will have only 1 operation no matter how man times it runs and it would be the most optimal code. 

O(log n) - Where your operations reduces in half for better results 
-------------------------------------------------------------------

Reduced number of operations means reduced memory consumption which could improve algorithms in terms of search 
If the approach is taken linearly.. say we need to print a million records, then it has to go through million operations 
But on the other hand, if a million is split into individual chucks of smaller elements its relatively faster to 
print all the elements. This is the concept behind O(log n) operations 

On checking a graph, its observed that o-log-n has a curve similar to that of O(1) but progresses narrowly up. 

O(a) and O(b) = > O(a+b)

This happens when a code has 2 different parameters 

For a nested forloop with different params 
we get O(a * b)


O(n)^2 -  A Loop within a loop 
O(n)   -  Proportional Algorithm 
O(log n) - Divide and Conquer 
O(1)   -  Constant 


+----------------------+
| Classes and Pointers |
+----------------------+

Classes :  Every data structure would be done with a class 

Classes are cookie cutters. You are creating a template through which your code is going to 
run. this would reduce the repeatability of your code 


Important points note about classes :  

- With a class you come up with something called the instance 
- Using the instance you create clones of your class called an instance object 
- So if the cookie cutter is star, then you create star cookies. If its heart then you create heart cookies 
- At the heart of a class you have the constructor. Which loads your inputs and transforms your class template to 
an object. This is where the real deal happens. Along with this you get to do add additional functionalities 
like 1 star cookie is yellow and another star cookie is yellow but has eyes nose and mouth 


Pointers :  

Remember pointers are references to different variables in memory. 
A pointer helps in directing to another variable. 

The best example you could give for a pointer is the value by constant and value by references 

Note the primitive data types are immutable and cannot be changed in memory. 
So if mr.mitch lives in grayson drive, he lives there... there is no way you can say he doesn't live there 
as it would be his constant residence 

meanwhile a mutable variable are objects which works on referencing each other 
If mrs.mitch is renting a house and goes to office the person who still lives in the house is mrs.mitch 
but she is in office and so the person in office is mrs.mitch as well 

Now you could ask somebody else to come and occupy the house evicting mrs.mitch (sad) but the new person who 
lives in that place if he goes to his office still the office and the house refer to that person. 

Although this analogy doesn't seems to go in align with what we are trying to say, you get the gist. 

while some have permanent resides others live in rented house 
which... means primitive data types have a constant memory address 
meanwhile reference data types refers to address to which the initial variable is located. 

+-------------------------------------------------------+
| Linked Lists -  Keeping memory addresses within a node|
+-------------------------------------------------------+

With a linked list, what you do is add references to the next element in a node. 
this so happens to help because your memory allocation gets distributed using all the spaces 
and you don't have to store all your elements in a linear fashion like a list. 

With this on board, you get to add your own custom index and references to your list elements
compared to your traditional way of indexing your list 

A linked list consists of a head and tail. A head is the starting point, while a tail is an end point 
With every element in a linked list, it points to the next element and at the end it points to none. 

+---------------------------+
| The Big-O of Linked Lists |
+---------------------------+

Before we go knee deep into this algorithm asymptotic notation 
its better we get a big picture out of it. 

So for this... you would need to understand the below elements 

Adding elements to a end of the Linked List = O(1) --> Because you add it at the end 
Removing elements at the end of a Linked List = O(n) --> Because you need to iterate through the entire list to find the element before last element 
Adding elements at the front of the Linked List = o(1) --> Because only one operation is required. 
Removing element at the front => O(1) --> Because only 1 operation is required 
Adding Elements in the middle => O(n) --> Because you iterate through elements 
Removing Elements in the middle => O(n) --> Because you iterate through elements

+-----------------------------+
| Linked Lists under the hood |
+-----------------------------+







