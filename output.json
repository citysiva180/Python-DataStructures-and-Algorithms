{
    "SNO": {
        "0": 1,
        "1": 2,
        "2": 3,
        "3": 4,
        "4": 5,
        "5": 6,
        "6": 7,
        "7": 8,
        "8": 9,
        "9": 10,
        "10": 11,
        "11": 12,
        "12": 13,
        "13": 14,
        "14": 15,
        "15": 16,
        "16": 17,
        "17": 18,
        "18": 19,
        "19": 20,
        "20": 21,
        "21": 22,
        "22": 23,
        "23": 24,
        "24": 25,
        "25": 26,
        "26": 27,
        "27": 28,
        "28": 29,
        "29": 30,
        "30": 31,
        "31": 32,
        "32": 33,
        "33": 34,
        "34": 35,
        "35": 36,
        "36": 37,
        "37": 38,
        "38": 39,
        "39": 40,
        "40": 41,
        "41": 42,
        "42": 43,
        "43": 44
    },
    "CATEGORY": {
        "0": "Managers and Queryset ",
        "1": "Managers and Queryset ",
        "2": "Managers and Queryset ",
        "3": "Managers and Queryset ",
        "4": "Retriving Objects",
        "5": "Retriving Objects",
        "6": "Retriving Objects",
        "7": "Filtering Objects",
        "8": "Filtering Objects",
        "9": "Filtering Objects",
        "10": "Filtering Objects",
        "11": "Filtering Objects",
        "12": "Filtering Objects",
        "13": "Filtering Objects",
        "14": "Complex Queries",
        "15": "Complex Queries",
        "16": "Complex Queries",
        "17": "Complex Queries",
        "18": "Using F Objects for References ",
        "19": "Sorting Data using ORM ",
        "20": "Sorting Data using ORM ",
        "21": "Sorting Data using ORM ",
        "22": "Sorting Data using ORM ",
        "23": "Sorting Data using ORM ",
        "24": "Limiting Results using Django ORM ",
        "25": "Limiting Results using Django ORM ",
        "26": "Selecting Field From Queries  ",
        "27": "Selecting Field From Queries  ",
        "28": "Selecting Field From Queries  ",
        "29": "Selecting Field From Queries  ",
        "30": "Selecting Field From Queries  ",
        "31": "DEFFERING FIELDS  ",
        "32": "Selecting Related Objects",
        "33": "Selecting Related Objects",
        "34": "Selecting Related Objects",
        "35": "Selecting Related Objects",
        "36": "Aggregate Object ",
        "37": "Aggregate Object ",
        "38": "Annotate Objects ",
        "39": "Database Functions",
        "40": "Database Functions",
        "41": "Group BY",
        "42": "Working With Expression Wrappers",
        "43": "Understanding QuerySet Cache "
    },
    "DESCRIPTION": {
        "0": "To get all rows in a table using ORM ",
        "1": "To filter results from table ",
        "2": "Using Order By in Django ORM",
        "3": "Getting the count",
        "4": "To get a single row",
        "5": "To get a single row based on a condition",
        "6": "Failsafe method to get a single row ",
        "7": "To find object greater than a number ",
        "8": "To find objects within a range ",
        "9": "To filter objects within a object attribute",
        "10": "To filter an object with a column value or a string ",
        "11": "To filter an object which starts with a certain string ",
        "12": "Using Date Time to find rows or objects",
        "13": "To Filter data which has null values ",
        "14": "Quering data with more than 1 conditions ",
        "15": "use Chain filtering to simplify the complex queries ",
        "16": "using q class for complex queries using OR operator ",
        "17": "Filtering objects with And Operators ",
        "18": "To reference a certain column based on other column, say if need to check we have no of cars has n number of parking spots etc we could use the F class to reference the models ",
        "19": "To Sort all the rows in ascending order ",
        "20": "To Sort all the rows with multiple parameters",
        "21": "To sort all the rows but reverse the sort ",
        "22": "To sort and get the first row in the Django ORM",
        "23": "To sort and get the first row in the Django ORM using earliest Method ",
        "24": "To Limit the results based on a number ",
        "25": "To Get the results or get a segment of results with a staring point and an endpoint, say second page results ",
        "26": "To select only few columns from the query set we could use the values function",
        "27": "To Select limited columns but from other tables as well",
        "28": "by Using Values__list you will get a tuple instead of a dictionary ",
        "29": "To get distinct values from a query set",
        "30": "Subqueries using django ORM ",
        "31": "To defer the loading of certain field to later ",
        "32": "Using Select Related Function to pre-load the columns that we need it quickly ",
        "33": "Pre-loading multiple columns with select_related ",
        "34": "Another way to load multiple associated fields, we could use the preload function",
        "35": "Combining Prefetch and Select Related",
        "36": "Aggregating Data | Count, Min, Max and Avg ",
        "37": "Aggregating Multiple Data ",
        "38": "Adding new columns based on expressions and values ",
        "39": "Referring database functions",
        "40": "Using Django In Built Concat function",
        "41": "Using Group By Function",
        "42": "Using the expression wrapper to give numerical and string expression to your query_set ",
        "43": "To implement cache "
    },
    "ORM SYNTAX": {
        "0": "queryset = <TableName>.object.all()",
        "1": "queryset.filter()",
        "2": "queryset.orderby()",
        "3": "queryset = <TableName>.object.count()",
        "4": "queryset = <TableName>.object.get()",
        "5": "product = <TableName>.objects.filter(pk=0).first()",
        "6": "product = <TableName>.objects.filter(pk=0).exists()",
        "7": "queryset = <TableName>.object.filter(column_name__gt=20)",
        "8": "query_set=<TableName>.objects.filter(column_name__range(x,y))",
        "9": "query_set=<TableName>.objects.filter(collection_id__range=(1,2,3))",
        "10": "query_set = <TableName>.objects.filter(title__icontains='coffee')",
        "11": "query_set = <TableName>.objects.filter(title__startswith='coffee')",
        "12": "query_set = <TableName>.objects.filter(title__last_update__year=2022)",
        "13": "query_set = <TableName>.objects.filter(description__isnull=True)",
        "14": "query_set = <TableName>.objects.filter(column_1__<coditions such as lt or gt>=<numerical or string value>,column_2__<coditions such as lt or gt>=<numerical or string value> )",
        "15": "# query_set = <TableName>.objects.filter(olumn_1__<coditions such as lt or gt>=<numerical or string value>).filter(column_2__<coditions such as lt or gt>=<numerical or string value>))",
        "16": "query_set = <TableName>.objects.filter(Q(condition_1) | Q(condition_2)) ",
        "17": "query_set = <TableName>.objects.filter(Q(condition_1) & ~Q(condition_2)) ",
        "18": "query_set = <TableName>.objects.filter(column_1 = F('column_2))",
        "19": "query_set = <TableName>.object.order_by('column_name')",
        "20": "query_set = <TableName>.object.order_by('column_1','-column_2')",
        "21": "query_set = <TableName>.object.order_by('column_1','-column_2').reverse()",
        "22": "query_set = <TableName>.objects.order_by('unit_price')[0]",
        "23": "query_set = <TableName>.objects.earliest('unit_price')",
        "24": "queryset = <TableName>.object.all()[:5]",
        "25": "queryset = <TableName>.object.all()[5:10]",
        "26": "query_set = Product.objects.values('id', 'title')",
        "27": "query_set = Product.objects.values('id', 'title','collection__id')",
        "28": "query_set = Product.objects.values_list('id', 'title','collection__id')",
        "29": "query_set = <TableName>.objects.values('product_id').distinct()",
        "30": " query_set = Product.objects.filter(id__in = OrderItem.objects.values('product_id').distinct())",
        "31": "query_set = <TableName>.objects.defer('column_1')",
        "32": "query_set = Product.objects.select_related('collection').all()",
        "33": "query_set = Product.objects.select_related('column_1__column_2').all()",
        "34": "query_set = Product.objects.prefetch_related('promotions').all()",
        "35": "query_set = <TableName>.objects.prefetch_related('column_1').select_related('column_2').all()",
        "36": "result = <TableName>.aggregate(Count('column_name'))",
        "37": "result = <TableName>.aggregate(count=Count('column_name'), min=Min('unit_price'))",
        "38": "query_set = <TableName>.objects.annotate(new_column_name=F(column_1)+1)",
        "39": "query_set = <TableName>.objects.annotate(new_column_name=Func(F('column_1'), Value(' '), F('column_2'), function='CONCAT'))",
        "40": "query_set = <TableName>.objects.annotate('column_1',Value(' '), 'column_2')",
        "41": "query_set = <TableName>.objects.annotate(new_column_name=Count('column_name'))",
        "42": "desired_column_name = ExpressionWrapper(F('column_value') <Any Expression of your choice>, output_filed=DecimalFiled())\r\n query_set = Products.objects.annotate(column_intended = query_set)",
        "43": "query_set = <TableName>.objects.all()\r\nlist(query_set)\r\nquery_set[0]"
    },
    "FUNCTIONALITY": {
        "0": "You can iterate or use the list function to display all the data | You can also index the list to display a single or range of rows of data. ",
        "1": "You could chain the filter method with another filter so you could filter from the results you got earlier. It will help in consecutive filtering, like, table of countries, filter 1 country and now, filter its states ",
        "2": "You could order your results using the orderby ",
        "3": "gets the count in a single row. Note that the returned value is just a single number. Hence further listing is not needed. ",
        "4": "You could pass a look up parameter like id so it would come quick from the system. Here you could also use PK= which is primary key in the system. If Object is not found you would get an exception. Use the ObjectDoesNotExist Exception to solve this issue. ",
        "5": "Does the same thing but no need for adding exception class for this ",
        "6": "This also checks if the object or row is present and then proceed with querying the data. These are the three major retrival functions ",
        "7": "Note that gt means its greater than. And it comes with an equal. Also note that the double underscore is a mandatory field. Without it the code wont work. Goto https:\/\/docs.djangoproject.com\/en\/4.0\/ref\/models\/querysets\/#field-lookups for more field lookups like this",
        "8": "Helps in getting objects within a range ",
        "9": "Will find products in the product table with the collection id 1,2 and 3",
        "10": "Remember, contains will bring out values and it would be case sensitive. If you need a case insensitive search use icontains instead of contains",
        "11": "There is also ends with or has etc. Checkout the django documentation for varied ORM functions to make this happen ",
        "12": "you could also use date and other options ",
        "13": "This would help you to find the rows with Null value ",
        "14": "Filters values based on 2 conditions at a single shot ",
        "15": "Filters values based on 2 conditions but consequently ",
        "16": "Two conditions combined using the OR Operator ",
        "17": "And Operators don\ufffdt need Q objects, you could directly apply your and operator with the ampersant symbol. Remember use the ~ symbol if you wish to negate the values in your query ",
        "18": "Using these references you could identify data from 1 table to another for similar values . ",
        "19": "To sort data in descending order just add the parameter as order_by('-column_name') which will solve the issue. ",
        "20": "It will sort in ascending order based on 1 column and then in descending order based on the second column ",
        "21": "Adding the reverse function will reverse the sort order of the query object ",
        "22": "This will bring the 1st row of the sorted data ",
        "23": "This will as well bring the first row of sorted data. Remember, order_by will bring a query_set but earliest will bring a constant ",
        "24": "This will bring first 5 rows of a table. It uses the Limit Syntax to make this happen ",
        "25": "This will bring rows from 5 to 10 from the table. This also helps in adding range to which the data has to be queried ",
        "26": "passing the column values as params to the values",
        "27": "Note that collection is a different table. The query puller or the ORM value function will do an inner join and join different tables and pull the data back. Note we would be getting dictionary as the queried result ",
        "28": "using Value list will give us a tuple of elements that we need. ",
        "29": "using the distinct function will give us distinct rows for the column mentioned ",
        "30": "By nesting some ORM queries within other queries we could achieve getting \/ retriving our desired results ",
        "31": "Doing this will bring all the data from table, except, the ones mentioned in the defer function ",
        "32": "It helps to pre-load the objects togather. If values function is used, its going to take up the entire table and clog your memory ",
        "33": "This helps in fetching more than 1 field in the fetch pre-load function ",
        "34": "Using Pre-fetch for quickly pre-loading related data ",
        "35": "Helps in pre-loading complex data piece. ",
        "36": "Will help in executing aggregate values such as min, max, count and average. Use the key name like count=Count('column_name') for custom nameing ",
        "37": "Multiple fields for aggregating data",
        "38": "Using the annotate function you could add expressions, f objects and references to your newly created column. Note that for boolean, ",
        "39": "You need to use the Func function, then F objects Value Objects etc\ufffd ",
        "40": "Syntax is much simple on using the inbuilt function. Remember, use django.db.models.functions to import Concat",
        "41": "I guess the count function helps you to do that and I get that it would work. ",
        "42": "You could split your expression to 2 part where you could get the column and output setting and then pass that expression into the annotate object to close the expression",
        "43": "Note that converting the query_set from the list and then calling the list functions will keep your list in memory. This inturn will help you in accessing your data with much speed. Use this technique to implement cahce. However, if you do the opposite but getting the first list value and converting the list, your queries will be much slower. So be careful in implementing cache in django "
    }
}