SNO,CATEGORY,DESCRIPTION,ORM SYNTAX,FUNCTIONALITY
1,Managers and Queryset ,To get all rows in a table using ORM ,queryset = <TableName>.object.all(),You can iterate or use the list function to display all the data | You can also index the list to display a single or range of rows of data. 
2,Managers and Queryset ,To filter results from table ,queryset.filter(),"You could chain the filter method with another filter so you could filter from the results you got earlier. It will help in consecutive filtering, like, table of countries, filter 1 country and now, filter its states "
3,Managers and Queryset ,Using Order By in Django ORM,queryset.orderby(),You could order your results using the orderby 
4,Managers and Queryset ,Getting the count,queryset = <TableName>.object.count(),gets the count in a single row. Note that the returned value is just a single number. Hence further listing is not needed. 
5,Retriving Objects,To get a single row,queryset = <TableName>.object.get(),You could pass a look up parameter like id so it would come quick from the system. Here you could also use PK= which is primary key in the system. If Object is not found you would get an exception. Use the ObjectDoesNotExist Exception to solve this issue. 
6,Retriving Objects,To get a single row based on a condition,product = <TableName>.objects.filter(pk=0).first(),Does the same thing but no need for adding exception class for this 
7,Retriving Objects,Failsafe method to get a single row ,product = <TableName>.objects.filter(pk=0).exists(),This also checks if the object or row is present and then proceed with querying the data. These are the three major retrival functions 
8,Filtering Objects,To find object greater than a number ,queryset = <TableName>.object.filter(column_name__gt=20),Note that gt means its greater than. And it comes with an equal. Also note that the double underscore is a mandatory field. Without it the code wont work. Goto https://docs.djangoproject.com/en/4.0/ref/models/querysets/#field-lookups for more field lookups like this
9,Filtering Objects,To find objects within a range ,"query_set=<TableName>.objects.filter(column_name__range(x,y))",Helps in getting objects within a range 
10,Filtering Objects,To filter objects within a object attribute,"query_set=<TableName>.objects.filter(collection_id__range=(1,2,3))","Will find products in the product table with the collection id 1,2 and 3"
11,Filtering Objects,To filter an object with a column value or a string ,query_set = <TableName>.objects.filter(title__icontains='coffee'),"Remember, contains will bring out values and it would be case sensitive. If you need a case insensitive search use icontains instead of contains"
12,Filtering Objects,To filter an object which starts with a certain string ,query_set = <TableName>.objects.filter(title__startswith='coffee'),There is also ends with or has etc. Checkout the django documentation for varied ORM functions to make this happen 
13,Filtering Objects,Using Date Time to find rows or objects,query_set = <TableName>.objects.filter(title__last_update__year=2022),you could also use date and other options 
14,Filtering Objects,To Filter data which has null values ,query_set = <TableName>.objects.filter(description__isnull=True),This would help you to find the rows with Null value 
15,Complex Queries,Quering data with more than 1 conditions ,"query_set = <TableName>.objects.filter(column_1__<coditions such as lt or gt>=<numerical or string value>,column_2__<coditions such as lt or gt>=<numerical or string value> )",Filters values based on 2 conditions at a single shot 
16,Complex Queries,use Chain filtering to simplify the complex queries ,# query_set = <TableName>.objects.filter(olumn_1__<coditions such as lt or gt>=<numerical or string value>).filter(column_2__<coditions such as lt or gt>=<numerical or string value>)),Filters values based on 2 conditions but consequently 
17,Complex Queries,using q class for complex queries using OR operator ,query_set = <TableName>.objects.filter(Q(condition_1) | Q(condition_2)) ,Two conditions combined using the OR Operator 
18,Complex Queries,Filtering objects with And Operators ,query_set = <TableName>.objects.filter(Q(condition_1) & ~Q(condition_2)) ,"And Operators don�t need Q objects, you could directly apply your and operator with the ampersant symbol. Remember use the ~ symbol if you wish to negate the values in your query "
19,Using F Objects for References ,"To reference a certain column based on other column, say if need to check we have no of cars has n number of parking spots etc we could use the F class to reference the models ",query_set = <TableName>.objects.filter(column_1 = F('column_2)),Using these references you could identify data from 1 table to another for similar values . 
20,Sorting Data using ORM ,To Sort all the rows in ascending order ,query_set = <TableName>.object.order_by('column_name'),To sort data in descending order just add the parameter as order_by('-column_name') which will solve the issue. 
21,Sorting Data using ORM ,To Sort all the rows with multiple parameters,"query_set = <TableName>.object.order_by('column_1','-column_2')",It will sort in ascending order based on 1 column and then in descending order based on the second column 
22,Sorting Data using ORM ,To sort all the rows but reverse the sort ,"query_set = <TableName>.object.order_by('column_1','-column_2').reverse()",Adding the reverse function will reverse the sort order of the query object 
23,Sorting Data using ORM ,To sort and get the first row in the Django ORM,query_set = <TableName>.objects.order_by('unit_price')[0],This will bring the 1st row of the sorted data 
24,Sorting Data using ORM ,To sort and get the first row in the Django ORM using earliest Method ,query_set = <TableName>.objects.earliest('unit_price'),"This will as well bring the first row of sorted data. Remember, order_by will bring a query_set but earliest will bring a constant "
25,Limiting Results using Django ORM ,To Limit the results based on a number ,queryset = <TableName>.object.all()[:5],This will bring first 5 rows of a table. It uses the Limit Syntax to make this happen 
26,Limiting Results using Django ORM ,"To Get the results or get a segment of results with a staring point and an endpoint, say second page results ",queryset = <TableName>.object.all()[5:10],This will bring rows from 5 to 10 from the table. This also helps in adding range to which the data has to be queried 
27,Selecting Field From Queries  ,To select only few columns from the query set we could use the values function,"query_set = Product.objects.values('id', 'title')",passing the column values as params to the values
28,Selecting Field From Queries  ,To Select limited columns but from other tables as well,"query_set = Product.objects.values('id', 'title','collection__id')",Note that collection is a different table. The query puller or the ORM value function will do an inner join and join different tables and pull the data back. Note we would be getting dictionary as the queried result 
29,Selecting Field From Queries  ,by Using Values__list you will get a tuple instead of a dictionary ,"query_set = Product.objects.values_list('id', 'title','collection__id')",using Value list will give us a tuple of elements that we need. 
30,Selecting Field From Queries  ,To get distinct values from a query set,query_set = <TableName>.objects.values('product_id').distinct(),using the distinct function will give us distinct rows for the column mentioned 
31,Selecting Field From Queries  ,Subqueries using django ORM , query_set = Product.objects.filter(id__in = OrderItem.objects.values('product_id').distinct()),By nesting some ORM queries within other queries we could achieve getting / retriving our desired results 
32,DEFFERING FIELDS  ,To defer the loading of certain field to later ,query_set = <TableName>.objects.defer('column_1'),"Doing this will bring all the data from table, except, the ones mentioned in the defer function "
33,Selecting Related Objects,Using Select Related Function to pre-load the columns that we need it quickly ,query_set = Product.objects.select_related('collection').all(),"It helps to pre-load the objects togather. If values function is used, its going to take up the entire table and clog your memory "
34,Selecting Related Objects,Pre-loading multiple columns with select_related ,query_set = Product.objects.select_related('column_1__column_2').all(),This helps in fetching more than 1 field in the fetch pre-load function 
35,Selecting Related Objects,"Another way to load multiple associated fields, we could use the preload function",query_set = Product.objects.prefetch_related('promotions').all(),Using Pre-fetch for quickly pre-loading related data 
36,Selecting Related Objects,Combining Prefetch and Select Related,query_set = <TableName>.objects.prefetch_related('column_1').select_related('column_2').all(),Helps in pre-loading complex data piece. 
37,Aggregate Object ,"Aggregating Data | Count, Min, Max and Avg ",result = <TableName>.aggregate(Count('column_name')),"Will help in executing aggregate values such as min, max, count and average. Use the key name like count=Count('column_name') for custom nameing "
38,Aggregate Object ,Aggregating Multiple Data ,"result = <TableName>.aggregate(count=Count('column_name'), min=Min('unit_price'))",Multiple fields for aggregating data
39,Annotate Objects ,Adding new columns based on expressions and values ,query_set = <TableName>.objects.annotate(new_column_name=F(column_1)+1),"Using the annotate function you could add expressions, f objects and references to your newly created column. Note that for boolean, "
40,Database Functions,Referring database functions,"query_set = <TableName>.objects.annotate(new_column_name=Func(F('column_1'), Value(' '), F('column_2'), function='CONCAT'))","You need to use the Func function, then F objects Value Objects etc� "
41,Database Functions,Using Django In Built Concat function,"query_set = <TableName>.objects.annotate('column_1',Value(' '), 'column_2')","Syntax is much simple on using the inbuilt function. Remember, use django.db.models.functions to import Concat"
42,Group BY,Using Group By Function,query_set = <TableName>.objects.annotate(new_column_name=Count('column_name')),I guess the count function helps you to do that and I get that it would work. 
43,Working With Expression Wrappers,Using the expression wrapper to give numerical and string expression to your query_set ,"desired_column_name = ExpressionWrapper(F('column_value') <Any Expression of your choice>, output_filed=DecimalFiled())
 query_set = Products.objects.annotate(column_intended = query_set)",You could split your expression to 2 part where you could get the column and output setting and then pass that expression into the annotate object to close the expression
44,Understanding QuerySet Cache ,To implement cache ,"query_set = <TableName>.objects.all()
list(query_set)
query_set[0]","Note that converting the query_set from the list and then calling the list functions will keep your list in memory. This inturn will help you in accessing your data with much speed. Use this technique to implement cahce. However, if you do the opposite but getting the first list value and converting the list, your queries will be much slower. So be careful in implementing cache in django "